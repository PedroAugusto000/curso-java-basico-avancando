===MEMBROS ESTÁTICOS===
- Também chamados de membros de classe
- São membros que fazem sentido independentemente de objetos. Não precisam de objeto para serem chamados. São chamados a partir do próprio nome da classe
- Aplicações comuns: Classes utilitárias, declaração de constantes
- Uma classe que possui somente membros estáticas, pode ser uma classe estática também. Esta classe não poderá ser instanciada

public static final double PI = 3.14159
public: Acessível de qualquer canto do código, até fora da classe.
static: Pertence à classe, não a um objeto específico.
final: Não pode ser mudado, é constante, se tentar reatribuir o valor o compilador já manda se foder.
double: Tipo decimal.

Com a classe estática não precisamos instanciar um objeto pra depois informar: Calculadora calc = New Calculadora(...);
Na chamada do método de uma classe estática podemos simplesmente fazer: Calculadora.circumference(radius); // Onde Calculadora é o nome da classe, circumference é o nome do método e radius é o atributo

===OPERAÇÕES IMPORTANTES COM DATA E HORA===
 - Data-hora local
1. LocalDate
2. LocalDateTime
 
 - Data-hora global
1. Instant

 - Duração
1. Duration

 - Outros
1. ZoneId
2. ChronoUnit

Pra especificar um timezone específico pro instant:
Instant hora = Instant.parse("2022-07-20T01:30:26-03:00") - Horário do Brasil é GMT-3

Formatando o DateTime
DateTimeFormatter fmt1 = DateTimeFormatter.ofPattern("dd/MM/yyyy");
DateTimeFormatter fmt2 =  DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");

===HERANÇA===

- Tipo de associação que permite que uma classe herde todos dados e comportamentos de outra
- ClasseA extends ClasseB + No constructor devemos informar os dados que gostaríamos de passar
- Temos de informar eles no parâmetro: 
	public BusinessAcount(Integer number, String holder, Double balance, Double loanlimit) {
	super(number, holder, balance);
	this.loanlimit = loanLimit
}

- Explicando agora o protected: Pode ser acessado por uma classe diferente do mesmo pacote ou uma subclasse, no nosso código a subclasse seria a BusinessAccount e a Account a super classe
OBS: É bastante útil para os atributos da nossa classe Account que nós geralmente colocamos ela como private, mas atributo privado a nossa subclasse não consegue consumir ela porque a private só libera pra própria classe. Então devemos trocar o atributo de private para protected

===Upcasting e downcasting===
Upcasting: Casting da subclasse para superclasse
Downcasting: Casting da superclasse para subclasse - Palavra instanceof - Uso comum é para métodos que recebem parâmetros genéricos (ex: Equals)

	// UPCASTING
		
	Account acc1 = bacc;
	Account acc2 = new BusinessAccount(1003, "Bob", 0.0, 200.0);
	Account acc3 = new SavingsAccount(1004, "Anna", 0.0, 0.01);
		
	// DOWNCASTING
		
	BusinessAccount acc4 = (BusinessAccount)acc2;
	acc4.loan(100.0);

***Explicando instanceof***
Se a gente tentar fazer dessa forma abaixo o compilador não vai dar erro, mas na hora da execução vai lançar uma CastException. Porque estamos tentando pegar a acc3 e informando pro compilador que ela é da (BusinessAccount), sendo que o objeto dela é da SavingsAccount:

Account acc3 = new SavingsAccount(1004, "Anna", 0.0, 0.01);
BusinessAccount acc5 = (BusinessAccount)acc3;

Para evitar disso acontecer podemos usar o instanceOf:

		if (acc3 instanceof BusinessAccount) {
			BusinessAccount acc5 = (BusinessAccount)acc3;
			acc5.loan(200.0);
			System.out.println("Loan!");
		}
		
		if (acc3 instanceof SavingsAccount) {
			SavingsAccount acc5 = (SavingsAccount)acc3;
			acc5.updateBalance();
			System.out.println("Update!");
		}

No caso acima antes de executar estamos verificando se o objeto do acc3 bate com o objeto informado na condição, tanto pra Business quanto pra Savings

===SOBREPOSIÇÃO OU ESCRITA===
- Implementação de um método de uma superclasse na subclasse
- Fortemente recomendável usar a anotação @Override em um método sobrescrito

Da pra chamar a implementação da superclasse usando a palavra super - super.metodo();

===CLASSES E MÉTODOS FINAL===
- Classe: Evita que a classe seja herdada (public final class Nome{})
- Método: Evita que seja sobreposto 

===Introdução ao polimorfismo===
Pilares da OOP
1. Encapsulamento
2. Herança
3. Polimorfismo

- É recurso que permite que variáveis de um mesmo tipo mais genérico possam apontar para objetos de tipos específicos diferentes
Account x = new Account (1020, "Alex", 1000.0);
x.withdraw(50.0);

Na stack está o x apontando para a heap com o valores de 1020 | Alex | 1000.0

- A associação do tipo específico com o tipo genérico é feita em tempo de execução (upcasting)
- O compilador não sabe qual tipo específico a chamada do método withdraw está sendo feita (Ele só sabe que são duas variáveis tipo Account)

===Interface===
Interface em Java é tipo a ponte entre o que tu quer fazer e como tu vai fazer. Ela serve como um contrato: diz o que precisa ser feito (os métodos), mas não mete o bedelho em como vai ser feito. Quem implementa a interface é que define o bagulho todo.

Muito útil para ser a intermediária da nossa aplicação e desacoplar os serviços. Você só depende agora da interface que não implementa nada, não da classe que faz o trabalho sujo!

public interface Animal {
    void fazerBarulho();
}

public class Cachorro implements Animal {
    public void fazerBarulho() {
        System.out.println("Au au!");
    }
}

public class Gato implements Animal {
    public void fazerBarulho() {
        System.out.println("Miau!");
    }
}

Explicando: Na interface então eu tipo defino o meu contrato, tipo ai no exemplo no meu contrato eu tenho que um animal tal deve fazer um barulho. Tendo isso em vista as outras classes tem de cumprir esse contrato informando algum animal fazendo algum barulho

===Inversão de controle e injeção de dependência===
Inversão de controle: Padrão de desenvolvimento que consiste em retirar da classe a responsabilidade de instanciar suas dependências
Injeção de dependência: Forma de realizar a inversão de controle: Um componente externo instancia a dependência, que então é injetada no objeto "pai". Pode ser implementada de várias formas (Construtor, classe de instanciação como "builder"/"factory", container ou framework...

- Acoplamento forte!
- Você vai ter uma classe que vai implementar essa interface. Na hora de fazer uma instanciação, por exemplo, você vai: RentalService rentalService = new RentalService(..., ... new BrazilTaxService)
- OBS: A nossa classe RentalService não conhece a BrazilTaxService, mas ela conhece a interface da TaxService que é a interface implementada na BrazilTaxService
- Isso se chama injeção de dependência por meio de construtor!
- Garante o desacoplamento e a flexibilidade da aplicação

===Herda vs cumprir contrato===
Herança: Reuso 
Interface: Contrato a ser cumprido

Na interface se presume que os métodos serão públicos e abstratos

- Para uma classe que queira implementar uma interface mas não quer cumprir o contrato de algum método devemos declarar ela como: public abstract class
- Assim ela deve passar tranquilamente mesmo tendo implements pra interface

===Herança múltipla e o problema do diamante===
- Ambiguidade causada pela existência do mesmo método em mais de uma superclasse
- Herança múltipla não é permitida na maioria das linguagens! (Quando uma classe tem de, teoricamente, herdar de duas classes. EX: Quer catar o método scan da classe Scanner e também o método print() de uma classe Printer

===Interface Comparable===
- A interface Comparable em Java é o contrato que diz como uma classe deve ser comparada com outra da mesma espécie, tá ligado? É tipo tu dizer pro Java:

"Ó, se tu quiser ordenar esses objetos aqui, é assim que tu vai comparar um com o outro."

- Ela é usada pra ordenar as paradas, seja lista, array, o caralho. Quando tu implementa Comparable, tu tá falando pro Java como ele deve saber quem é maior, menor ou igual dentro dos teus próprios objetos.

public class Pessoa implements Comparable<Pessoa> {
    private String nome;
    private int idade;

    public Pessoa(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }

    @Override
    public int compareTo(Pessoa outraPessoa) {
        return Integer.compare(this.idade, outraPessoa.idade);
    }
}

List<Pessoa> lista = new ArrayList<>();
lista.add(new Pessoa("João", 30));
lista.add(new Pessoa("Ana", 25));
lista.add(new Pessoa("Carlos", 40));

Collections.sort(lista); // Java já sabe como ordenar pelo compareTo - Collections.sort é uma forma de ordenar uma coleção

Método compareTo: Ele retorna um inteiro porque ele devolve o resultado com base nisso: 
sysout("maria".comparetTo("alex")); //Deve devolver um n° positivo 12, maria é maior que alex (Ordem alfabética)
sysout("alex".comparetTo("maria")); //Deve devolver um n° negativo -12, alex é menor que maria (Ordem alfabética)
sysout("maria".comparetTo("maria")); //Deve devolver 0, maria é igual a maria

===Default methods (Defender methods)===
- A partir do Java 8, interfaces podem conter métodos concretos
- A intenção básica é prover implementação padrão para métodos, de modo a evitar
1) Repetição de implementação em toda classe que implementa a interface
2) Necessidade de criar classes abstratas para prover reuso da implementação

Os default methods, também conhecidos como defender methods, são tipo uma gambiarra oficializada com classe, saca? Vieram no Java 8 pra dar poder pras interfaces, sem quebrar tudo que já existia nos projetos antigos.

Normalmente, interface era só contrato: só dizia o que fazer, mas não fazia nada.
Com os default, agora a interface pode dizer:
“Ó, se ninguém implementar essa porra aqui, eu mesmo dou conta do recado.”

É só meter default na frente do método e escrever o corpo dele ali mesmo dentro da interface:

public interface Animal {
    default void respirar() {
        System.out.println("Respirando como todo bicho vivo.");
    }

    void fazerBarulho(); // ainda pode ter método sem corpo também
}

public class Cachorro implements Animal {
    public void fazerBarulho() {
        System.out.println("Au au!");
    }

    // não precisa implementar respirar(), já vem da interface
}

