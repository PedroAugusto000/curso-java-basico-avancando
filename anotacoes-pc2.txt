===MEMBROS ESTÁTICOS===
- Também chamados de membros de classe
- São membros que fazem sentido independentemente de objetos. Não precisam de objeto para serem chamados. São chamados a partir do próprio nome da classe
- Aplicações comuns: Classes utilitárias, declaração de constantes
- Uma classe que possui somente membros estáticas, pode ser uma classe estática também. Esta classe não poderá ser instanciada

public static final double PI = 3.14159
public: Acessível de qualquer canto do código, até fora da classe.
static: Pertence à classe, não a um objeto específico.
final: Não pode ser mudado, é constante, se tentar reatribuir o valor o compilador já manda se foder.
double: Tipo decimal.

Com a classe estática não precisamos instanciar um objeto pra depois informar: Calculadora calc = New Calculadora(...);
Na chamada do método de uma classe estática podemos simplesmente fazer: Calculadora.circumference(radius); // Onde Calculadora é o nome da classe, circumference é o nome do método e radius é o atributo

===OPERAÇÕES IMPORTANTES COM DATA E HORA===
 - Data-hora local
1. LocalDate
2. LocalDateTime
 
 - Data-hora global
1. Instant

 - Duração
1. Duration

 - Outros
1. ZoneId
2. ChronoUnit

Pra especificar um timezone específico pro instant:
Instant hora = Instant.parse("2022-07-20T01:30:26-03:00") - Horário do Brasil é GMT-3

Formatando o DateTime
DateTimeFormatter fmt1 = DateTimeFormatter.ofPattern("dd/MM/yyyy");
DateTimeFormatter fmt2 =  DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");

===HERANÇA===

- Tipo de associação que permite que uma classe herde todos dados e comportamentos de outra
- ClasseA extends ClasseB + No constructor devemos informar os dados que gostaríamos de passar
- Temos de informar eles no parâmetro: 
	public BusinessAcount(Integer number, String holder, Double balance, Double loanlimit) {
	super(number, holder, balance);
	this.loanlimit = loanLimit
}

- Explicando agora o protected: Pode ser acessado por uma classe diferente do mesmo pacote ou uma subclasse, no nosso código a subclasse seria a BusinessAccount e a Account a super classe
OBS: É bastante útil para os atributos da nossa classe Account que nós geralmente colocamos ela como private, mas atributo privado a nossa subclasse não consegue consumir ela porque a private só libera pra própria classe. Então devemos trocar o atributo de private para protected

===Upcasting e downcasting===
Upcasting: Casting da subclasse para superclasse
Downcasting: Casting da superclasse para subclasse - Palavra instanceof - Uso comum é para métodos que recebem parâmetros genéricos (ex: Equals)

	// UPCASTING
		
	Account acc1 = bacc;
	Account acc2 = new BusinessAccount(1003, "Bob", 0.0, 200.0);
	Account acc3 = new SavingsAccount(1004, "Anna", 0.0, 0.01);
		
	// DOWNCASTING
		
	BusinessAccount acc4 = (BusinessAccount)acc2;
	acc4.loan(100.0);

***Explicando instanceof***
Se a gente tentar fazer dessa forma abaixo o compilador não vai dar erro, mas na hora da execução vai lançar uma CastException. Porque estamos tentando pegar a acc3 e informando pro compilador que ela é da (BusinessAccount), sendo que o objeto dela é da SavingsAccount:

Account acc3 = new SavingsAccount(1004, "Anna", 0.0, 0.01);
BusinessAccount acc5 = (BusinessAccount)acc3;

Para evitar disso acontecer podemos usar o instanceOf:

		if (acc3 instanceof BusinessAccount) {
			BusinessAccount acc5 = (BusinessAccount)acc3;
			acc5.loan(200.0);
			System.out.println("Loan!");
		}
		
		if (acc3 instanceof SavingsAccount) {
			SavingsAccount acc5 = (SavingsAccount)acc3;
			acc5.updateBalance();
			System.out.println("Update!");
		}

No caso acima antes de executar estamos verificando se o objeto do acc3 bate com o objeto informado na condição, tanto pra Business quanto pra Savings

===SOBREPOSIÇÃO OU ESCRITA===
- Implementação de um método de uma superclasse na subclasse
- Fortemente recomendável usar a anotação @Override em um método sobrescrito

Da pra chamar a implementação da superclasse usando a palavra super - super.metodo();

===CLASSES E MÉTODOS FINAL===
- Classe: Evita que a classe seja herdada (public final class Nome{})
- Método: Evita que seja sobreposto 

===Introdução ao polimorfismo===
Pilares da OOP
1. Encapsulamento
2. Herança
3. Polimorfismo

- É recurso que permite que variáveis de um mesmo tipo mais genérico possam apontar para objetos de tipos específicos diferentes
Account x = new Account (1020, "Alex", 1000.0);
x.withdraw(50.0);

Na stack está o x apontando para a heap com o valores de 1020 | Alex | 1000.0

- A associação do tipo específico com o tipo genérico é feita em tempo de execução (upcasting)
- O compilador não sabe qual tipo específico a chamada do método withdraw está sendo feita (Ele só sabe que são duas variáveis tipo Account)

===Interface===
Interface em Java é tipo a ponte entre o que tu quer fazer e como tu vai fazer. Ela serve como um contrato: diz o que precisa ser feito (os métodos), mas não mete o bedelho em como vai ser feito. Quem implementa a interface é que define o bagulho todo.

Muito útil para ser a intermediária da nossa aplicação e desacoplar os serviços. Você só depende agora da interface que não implementa nada, não da classe que faz o trabalho sujo!

public interface Animal {
    void fazerBarulho();
}

public class Cachorro implements Animal {
    public void fazerBarulho() {
        System.out.println("Au au!");
    }
}

public class Gato implements Animal {
    public void fazerBarulho() {
        System.out.println("Miau!");
    }
}

Explicando: Na interface então eu tipo defino o meu contrato, tipo ai no exemplo no meu contrato eu tenho que um animal tal deve fazer um barulho. Tendo isso em vista as outras classes tem de cumprir esse contrato informando algum animal fazendo algum barulho

===Inversão de controle e injeção de dependência===
Inversão de controle: Padrão de desenvolvimento que consiste em retirar da classe a responsabilidade de instanciar suas dependências
Injeção de dependência: Forma de realizar a inversão de controle: Um componente externo instancia a dependência, que então é injetada no objeto "pai". Pode ser implementada de várias formas (Construtor, classe de instanciação como "builder"/"factory", container ou framework...

- Acoplamento forte!
- Você vai ter uma classe que vai implementar essa interface. Na hora de fazer uma instanciação, por exemplo, você vai: RentalService rentalService = new RentalService(..., ... new BrazilTaxService)
- OBS: A nossa classe RentalService não conhece a BrazilTaxService, mas ela conhece a interface da TaxService que é a interface implementada na BrazilTaxService
- Isso se chama injeção de dependência por meio de construtor!
- Garante o desacoplamento e a flexibilidade da aplicação

===Herda vs cumprir contrato===
Herança: Reuso 
Interface: Contrato a ser cumprido

Na interface se presume que os métodos serão públicos e abstratos

- Para uma classe que queira implementar uma interface mas não quer cumprir o contrato de algum método devemos declarar ela como: public abstract class
- Assim ela deve passar tranquilamente mesmo tendo implements pra interface

===Herança múltipla e o problema do diamante===
- Ambiguidade causada pela existência do mesmo método em mais de uma superclasse
- Herança múltipla não é permitida na maioria das linguagens! (Quando uma classe tem de, teoricamente, herdar de duas classes. EX: Quer catar o método scan da classe Scanner e também o método print() de uma classe Printer

===Interface Comparable===
- A interface Comparable em Java é o contrato que diz como uma classe deve ser comparada com outra da mesma espécie, tá ligado? É tipo tu dizer pro Java:

"Ó, se tu quiser ordenar esses objetos aqui, é assim que tu vai comparar um com o outro."

- Ela é usada pra ordenar as paradas, seja lista, array, o caralho. Quando tu implementa Comparable, tu tá falando pro Java como ele deve saber quem é maior, menor ou igual dentro dos teus próprios objetos.

public class Pessoa implements Comparable<Pessoa> {
    private String nome;
    private int idade;

    public Pessoa(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }

    @Override
    public int compareTo(Pessoa outraPessoa) {
        return Integer.compare(this.idade, outraPessoa.idade);
    }
}

List<Pessoa> lista = new ArrayList<>();
lista.add(new Pessoa("João", 30));
lista.add(new Pessoa("Ana", 25));
lista.add(new Pessoa("Carlos", 40));

Collections.sort(lista); // Java já sabe como ordenar pelo compareTo - Collections.sort é uma forma de ordenar uma coleção

Método compareTo: Ele retorna um inteiro porque ele devolve o resultado com base nisso: 
sysout("maria".comparetTo("alex")); //Deve devolver um n° positivo 12, maria é maior que alex (Ordem alfabética)
sysout("alex".comparetTo("maria")); //Deve devolver um n° negativo -12, alex é menor que maria (Ordem alfabética)
sysout("maria".comparetTo("maria")); //Deve devolver 0, maria é igual a maria

===Default methods (Defender methods)===
- A partir do Java 8, interfaces podem conter métodos concretos
- A intenção básica é prover implementação padrão para métodos, de modo a evitar
1) Repetição de implementação em toda classe que implementa a interface
2) Necessidade de criar classes abstratas para prover reuso da implementação

Os default methods, também conhecidos como defender methods, são tipo uma gambiarra oficializada com classe, saca? Vieram no Java 8 pra dar poder pras interfaces, sem quebrar tudo que já existia nos projetos antigos.

Normalmente, interface era só contrato: só dizia o que fazer, mas não fazia nada.
Com os default, agora a interface pode dizer:
“Ó, se ninguém implementar essa porra aqui, eu mesmo dou conta do recado.”

É só meter default na frente do método e escrever o corpo dele ali mesmo dentro da interface:

public interface Animal {
    default void respirar() {
        System.out.println("Respirando como todo bicho vivo.");
    }

    void fazerBarulho(); // ainda pode ter método sem corpo também
}

public class Cachorro implements Animal {
    public void fazerBarulho() {
        System.out.println("Au au!");
    }

    // não precisa implementar respirar(), já vem da interface
}

===INTRODUÇÃO A GENERICS===

- Generics permitem que classes, interfaces e métodos possam ser parametrizados por tipo. Seus benefícios são:
1) Reuso
2) Type safety
3) Performance

Imagina que tu quer criar uma classe Caixa, que guarda qualquer coisa, qualquer tipo — pode ser String, Integer, Cachorro, Carro, o escambau. Sem generics, tu teria que usar Object, tipo assim:

public class Caixa {
    private Object coisa;

    public void guardar(Object coisa) {
        this.coisa = coisa;
    }

    public Object pegar() {
        return coisa;
    }
}

Tem de fazer esse casting
Caixa c = new Caixa();
c.guardar("Salve maloqueiro");
String s = (String) c.pegar(); // Tem que forçar o tipo aqui

Se errar o programa vai estourar em tempo de execução 
c.guardar(123);
String s = (String) c.pegar(); 

AGORA COM GENERICS
public class Caixa<T> {
    private T coisa;

    public void guardar(T coisa) {
        this.coisa = coisa;
    }

    public T pegar() {
        return coisa;
    }
}

Caixa<String> caixaDeString = new Caixa<>();
caixaDeString.guardar("Fala fiote");
String texto = caixaDeString.pegar(); // Sem cast, sem dor, só amor

===GENÉRICOS DELIMITADOS (Bounded types)===

Às vezes tu quer que o tipo genérico só aceite certos tipos, tipo: "só quero que isso aceite números", ou "tem que ser um tipo que herda de Animal".

Aí tu usa extends (mesmo se for interface, o Java usa extends):

public class Calculadora<T extends Number> {
    public double somar(T a, T b) {
        return a.doubleValue() + b.doubleValue();
    }
}

Calculadora<Integer> calcInt = new Calculadora<>();
System.out.println(calcInt.somar(5, 10)); // 15.0

Calculadora<String> calcErrada = new Calculadora<>(); // Vai dar erro de compilação

===TIPOS CURINGA===

Exemplo: 
List<Object> myObjs = new ArrayList<>();
List<Integer> myNumbers = new ArrayList<>();
myObjs = myNumbers; //erro de compilação
Explicação: Por mais que Integer seja uma subclasse de Object, uma lista de object não é um supertipo de qualquer tipo de lista, pra funcionar podemos usar um tipo curinga

List<?> myObjs = new ArrayList<Object>();
List<Integer> myNumbers = new ArrayList<>();
myObjs = myNumbers; 

OBS: Não podemos adicionar dados a uma coleção de tipo curinga (list.add(3) pra uma lista de List<?> list

===CURINGAS DELIMITADOS (Bounded wildcards)===

Aquela mesma fita: Nós temos uma interface de Shape que é implementada em duas classes, circle e rectangle. Só que uma lista de <Shape> não é um supertipo pra uma lista de <Circle> ou <Rectangle>

Por isso podemos informar pro compilador que:

public static double totalarea(List<? extends Shape> list) // Devemos fazer isso para informar pro compilador qual tipo a nossa lista vai receber, se não ele vai reclamar que não necessariamente a minha lista vai receber dados tipo Shape

===hashCode e equals===
- As duas são operações da classe Object utilizadas para comparar se um objeto é igual ao outro
equals: lento, resposta 100% - Não erra nem fudendno
hashCode: rápido, porém resposta positiva não é 100% - Pequena possibilidade dar um falso positivo

- Tipos comuns (String, Date, Integer, Double, etc) já possuem implementação para essas operações. Classes personalizadas precisam sobrepô-las

sysout(a.equals(b));
sysout(a.hashCode()); // Vai imprimir um número
sysout(b.hashCode()); // Vai imprimir um número

Qual a diferença de usar o ==: Esse == ele bate utilizando os endereços de memória dos dados. False pra se os endereços não baterem ou True para caso os endereços sejam iguais

===SET<T>===

- Representa um conjunto de elementos (similar ao da Álgebra)
1) Não admite repetições
2) Elementos não possuem posição
3) Acesso, inserção e remoção de elementos são rápidos
4) oferece operações eficientes de conjunto: interseção, união, diferença
5) Principais implementações:
HashSet - Mais rápido (operação O(1) em tabela hash) e não ordenado
TreeSet - Mais lento (operações O(log(n)) em árvore rubro-negra) e ordenado pelo compareTo do objeto (Ou Comparator)
LinkedHashSet - Velocidade intermediária e elementos na ordem em que são adicionados

Alguns méotodos importantes dele:
1 - add(obj)
2 - remove(obj)
3- contains(obj)
4 - clear()
5 - size()
6 - removeIf(predicate)
7 - addAll(other): adiciona no conjunto de elementos do outro conjunto sem repetição
8 - retainAll(other): remove do conjunto os elementos não contidos em other
9 - removeAll: remove do conjunto os elementos contidos em other

#Usa bastante os conceitos de união, interseção e diferença#

O set utilizada, caso tenha hashCode e equals, ele vai verificar os com o hashCode e confirmar com o equals. SE NÃO tiver ele só vai comparar as referências (ponteiros) dos objetos

===Map===

- É uma coleção de pares chave / valor
Não permite repetições do objeto chave;
Os elementos são indexados pelo objeto chave (não possuem posição);
Acesso, inserção e remoção de elementos são rápidos.

- Uso comum: cookies, local storage, qualquer modelo chave-valor

- Principais implementações
HashMap
TreeMap
LinkedHashMap

- Métodos importantes:
put(key, value), remove(key), containsKey(key), get(key)

Baseados em equals e hashCode. Se não existir, é comparado pelos ponteiros

clear(), size(), keySet() // Retorna um Set<K>, values() // Retorna um Collection<V>

===INTERFACE FUNCIONAL===

É uma interface que possui um único método abstrato. Suas implementações serão tratadas como expressões lambdas

public class MyComparator implements Comparator<Product> {
	@Override
	public int compare(Product p1, Product p2) {
	return p1.getName().toUpperCase().compareTo(p2.getName().toUpperCase());
	}
}

public static void main (String[] args) {
	list.sort(new MyComparator());
}

===PREDICATE===
É uma interface generics e contém apenas um método abstrato chamado "test"

public interface Predicate<T> {
	boolean test(T t);
}

Por exemplo:

List<Product> list = new ArrayList<>();
list.removeIf(p -> p.getPrice() >= 100);

Abrimos uma classe que vai implementar a interface do Predicate:
public class ProductPredicate implements Predicate<Product> {
	@Override
	public boolean test(Product p) {
		return p.getPrice() >= 100.00;
	}
}

Ai lá no programa podemos substituir:
List<Product> list = new ArrayList<>();
list.removeIf(new ProductPredicate());

Assim como tem várias outras formas de implementar essa funcionalidade...

MethodReference: Product::staticProductPredicate

===CONSUMER===

- A Consumer<T> é uma interface funcional do Java, tá no pacote java.util.function, e o bagulho serve pra quando tu quer fazer uma ação com um valor, mas sem retornar nada.

- Só tem um método: accept(T t). Ele recebe um valor do tipo T e faz alguma coisa com ele, mas não devolve nada (void). O foco é executar uma ação com efeito colateral (tipo imprimir, salvar, alterar algo etc).

public class ExemploConsumer {
    public static void main(String[] args) {
        List<String> nomes = Arrays.asList("João", "Maria", "Pedro");

        Consumer<String> imprimirMaiusculo = nome -> System.out.println(nome.toUpperCase());

        nomes.forEach(imprimirMaiusculo);
    }
}

Saída: 
JOÃO
MARIA
PEDRO

===Interface Function<T, R>===
- Function<T, R> aí é das braba no Java, faz parte da API de funções lambda que veio com o Java 8. É usada pra representar uma função que recebe um valor do tipo T e devolve um valor do tipo R.

@FunctionalInterface
public interface Function<T, R> {
    R apply(T t); // método que tu implementa
}

Exemplo:
Function<Integer, String> intPraString = (num) -> "Número: " + num;

String resultado = intPraString.apply(5);

System.out.println(resultado); // sai "Número: 5"

Exemplo com Map:
List<Integer> numeros = List.of(1, 2, 3, 4);

List<String> resultado = numeros.stream()
    .map(n -> "Número: " + n) // Function<Integer, String>
    .toList();

System.out.println(resultado);

===SIGNIFICADO PARÂMETROS TIPO GENÉRICO===
T	Type (Tipo genérico qualquer)	Tipo comumzão: T, List<T>, Consumer<T>
E	Element (Elemento)	Usado em coleção tipo List<E>, Set<E>
K	Key (Chave)	Usado em Map<K, V> pra chave
V	Value (Valor)	Usado em Map<K, V> pro valor
S, U, R, etc	Tipos adicionais/complementares	Quando tu tem mais de um genérico (tipo copy(List<? extends T>, List<? super T>))

===CRIANDO FUNÇÕES QUE RECEBEM FUNÇÕES COMO ARGUMENTO===

fazerAlgo(String texto, Consumer<String> acao)
fazerAlgo("E aí mano", t -> System.out.println(t.toUpperCase()));
//Tu tá mandando a função t -> System.out.println(...) como argumento!

Exemplo+
public class FuncoesComArgumento {

    public static void main(String[] args) {
        // Chamando e passando a função como argumento
        executarComTexto("salve maloqueiro", texto -> {
            System.out.println("Texto em capslock: " + texto.toUpperCase());
        });

        // Outro exemplo passando println direto
        executarComTexto("vamo codar", System.out::println);
    }

    // Esse método recebe uma função que consome uma String (Consumer<String>)
    public static void executarComTexto(String texto, Consumer<String> funcao) {
        System.out.println("Executando função com o texto: " + texto);
        funcao.accept(texto);
    }
}

Saída: 
Executando função com o texto: salve maloqueiro
Texto em capslock: SALVE MALOQUEIRO
Executando função com o texto: vamo codar
vamo codar

===STREAM===
- Sequencia de elementos advinda de uma fonte de dados que oferece suporte a "operações agregadas"
- Stream é uma solução para processar sequência de dados de forma:
Declarativa (iteração interna: escondida do programador)
Parallel-friendly (imutável -> thread safe)
Sem efeitos colaterais
Sob demanda (lazy evaluation)

- Acesso sequencial (não há índices) Consome ela um por um
- Single-use: só pode ser "usada" uma vez
- Pipeline: operações em streams retornam novas streams. Então é possível criar uma cadeia de operações (fluxo de processamento)

Operações Intermediárias e Terminais
- O pipeline é composto por zero ou mais operações intermediárias e uma terminal.
- Operação intermediária:
Produz uma nova streams (encadeamento)
Só executa quando uma operação terminal é invocada (lazy evaluation)
- Operação terminal:
Produz um objeto não-stream (coleção ou outro)
Determina o fim do processamento da stream

Operações intermediárias
• filter
• map
• flatmap
• peek
• distinct
• sorted
• skip
• limit (*)

Operações terminais
• forEach
• forEachOrdered
• toArray
• reduce
• collect
• min
• max
• count
• anyMatch (*)
• allMatch (*)
• noneMatch (*)
• findFirst (*)
• findAny (*)

- Basta chamar o método stream() ou parallelStream() a partir de qualquer objeto Collection.
- Outras formas de se criar uma stream incluem:
• Stream.of
• Stream.ofNullable
• Stream.iterate

Exemplo básico:
List<String> nomes = Arrays.asList("maria", "joão", "pedro", "ana");

nomes.stream()
    .filter(nome -> nome.length() > 3)     // só quem tem mais de 3 letras
    .map(String::toUpperCase)              // transforma pra maiúsculo
    .sorted()                              // ordena
    .forEach(System.out::println);         // imprime

Saída:
JOÃO
MARIA
PEDRO

===Pipeline (demo)===

List<Integer> list = Arrays.asList(3, 4, 5, 10, 7);

Stream<Integer> st1 = list.stream().map(x -> x * 10);
System.out.println(Arrays.toString(st1.toArray()));

int sum = list.stream().reduce(0, (x, y) -> x + y);
System.out.println("Sum = " + sum);

List<Integer> newList = list.stream()
	.filter(x -> x % 2 == 0)
	.map(x -> x * 10)
	.collect(Collectors.toList());
System.out.println(Arrays.toString(newList.toArray()));
